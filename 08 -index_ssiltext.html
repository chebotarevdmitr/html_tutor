<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ssilka_v tekste</title>
</head>
<body>
 <h1>Ссылки</h1>
  <h2>Ссылки внутри страници</h2>
 <ul>
    <li><a href="#first-story">Первая история</a></li>
    <li><a href="#second-story">Вторая история</a></li>
    <li><a href="#third-story">Третья история</a></li>
 </ul> 
 <h2 id="first-story">Первая история &ndash; realizaciya</h2>
 <p>Из этой книги вы узнаете, как правильно реализовать алгоритмы и структуры данных,
достойные реализации (а есть и такие, которые этого не достойны!). Предполагается,
что вы уже знакомы с основными понятиями на уровне вводного курса алгоритмов.
В этой книге:
рассмотрено множество специализированных тем;
по более общим, стандартным темам приведен дополнительный материал, необходимый для их полного понимания. Например: «Как
реализовать приоритетную очередь с отслеживанием элементов для алгоритмов поиска кратчайшего пути?»;
предлагаются однозначные решения, какие алгоритмы и структуры данных лучше
в той или иной ситуации использовать. В некоторых завершающих книгу главах
именно эта информация, возможно, станет для читателя самой полезной. Но понимать предпосылки тех или иных решений все же
важнее.
Иногда известные алгоритмы оказывались недостаточно хороши, поэтому я придумывал свои собственные. Вы не сможете найти
их в каком-либо другом источнике. Вот
некоторые из них:свободный список со сборкой мусора (см. главу 5. Фундаментальные структуры
данных);
куча сумм (см. главу 6. Генерация случайных чисел);
реализация универсальной хеш-функции для массивов на основе исключающего
ИЛИ со сдвигом (см. главу 9. Хеширование);
использование проверки знака для принятия решений и сокращения дерева регрессии (см. главу 26. Машинное обучение:
классификация);
эффективная реализация k-метода (см. главу 28. Машинное обучение: кластеризация).
В идеальном мире каждый ключевой шаг в создании алгоритма должен быть общеизвестен, тщательно исследован и проверен. Мои
находки тоже нуждаются в такой проверке, хотя, надеюсь, по крайней мере некоторые из них обладают реальной научной
ценностью. Если вы занимаетесь исследованиями, не стесняйтесь направлять любые
вопросы мне на электронную почту.
В качестве строительных блоков для более сложных алгоритмов и структур данных
я использую решения, описанные в книге, а не взятые из стандартной библиотеки шаблонов C++ STL. Это дает возможность
лучше тестировать код и предоставляет опреде-
20 Предисловие
ленные преимущества с точки зрения удобства работы. Например, в моей собственной
реализации вектора, которая позволяет удобно работать с последним элементом, я выловил бессчетное множество ошибок,
связанных с проверками границ в operator[].
Разумеется, для реальной разработки предпочтительнее использовать устоявшиеся
библиотеки, поскольку они стандартны и более надежны. Мои примеры тоже неплохо
проверены, но могут служить лишь отправной точкой для хорошей реализации.
Для простоты я не задействую в книге многие новейшие функции C++. Например, семантика перемещения позволяет повысить
эффективность кода, если у объектов есть
эффективные деструкторы, но в остальных случаях достаточно встроенной оптимизации от компилятора. Тем не менее в книге
эти процессы описаны достаточно углубленно, поэтому для ее освоения необходимы некоторые знания в области вычислительной
техники и математики. В главах, посвященных специализированным темам типа численных алгоритмов, вам потребуется
знакомство с определенными разделами математики — например, с линейной алгеброй. Некоторые более поздние главы опираются
на
более ранние. Упражнений в книге нет, но в ряде глав представлены проекты, которые
вы можете развить. Обычно они требуют исследования и тщательной реализации, до
которой я, как правило, не доходил.
Эту книгу лучше всего использовать в качестве дополнения к книгам, в которых рассматриваются базовые понятия (особенно
это касается последних глав). Я не утверждаю, что мои реализации идеальны. Они, скорее, представляют собой первый шаг
в правильном направлении. Я внимательно отнесся к составлению списка литературы,
и если вы не найдете в нем некоторых популярных книг по той или иной теме, то это,
скорее всего, связано с тем, что я подошел к нему весьма избирательно. В книгах других авторов, как правило, приводится
больше примеров и математики, но гораздо
меньше деталей реализации, и лучше познакомиться с несколькими разными изданиями, чтобы лучше усвоить материалh</p>
 
<h2 id="second-story">Вторая история &ndash; netrivialnie</h2>
<p>Нетривиальные алгоритмы приходится реализовывать редко, так как они бывают уже
доступны в тех или иных API. В программировании большая часть усилий уходит на
логическое моделирование системы, выполняемое экспертами в предметной области.
Но иногда важно понимать, что делает API в принципе, и иметь возможность изменить
или расширить имеющуюся реализацию. Кроме того, кто-то должен разрабатывать
и поддерживать API, а для различных встроенных устройств это делается обычно либо
с нуля, либо путем адаптации имеющихся аналогичных API.
В этой книге будут рассмотрены — за некоторыми исключениями — только те алгоритмы, которые предназначены для реального
применения. Теоретические алгоритмы,
существующие, по всей видимости, только благодаря любопытству исследователей,
хорошо изложены в книге [1.6]1
.
В этой главе рассматриваются некоторые темы, к которым нам предстоит неоднократно
вернутьсya</p>

<h2 id="third-story">Третья история &ndash; algoritm</h2>
 <p>Алгоритм — это четко определенное преобразование входных данных в выходные.
Эффективный доступ и обновление сохраненных данных обеспечивает структура данных. Для поддержания успешной разработки
программного обеспечения и алгоритм,
и структура данных должны быть:
корректными — то есть давать удовлетворительное решение поставленной задачи.
Чтобы признать алгоритм и его реализацию правильными, нужны формальные доказательства, всестороннее тестирование или
интуиция. В корректности алгоритма и
структуры данных никогда нельзя быть уверенным на сто процентов, потому что
формальные доказательства не всегда можно получить, интуиция может ошибаться,
а логика, к которой редко обращаются, трудно проверяется. Корректность может
опираться и на вероятность событий, поэтому алгоритм, который ошибается реже,

1
Список рекомендуемой литературы приводится в конце каждой главы.
22 Глава 1
чем в ваш компьютер бьет молния, можно считать правильным. Алгоритм должен
сообщать об ошибках — например, о невозможности выделения памяти;
расширяемыми — то есть применимыми к общим проблемам при внесении небольших изменений. В реальных задачах иногда
присутствуют дополнительные ограничения, из-за которых требуется доработка существующих алгоритмов. Алгоритм,
применимый к некоторому семейству задач, более ценен, чем набор более эффективных специальных алгоритмов для решения
каждой конкретной задачи. Реализация считается расширяемой, если ее код можно без изменений применять ко множеству
задач. Всегда отдавайте предпочтение коду, допускающему многократное
использование, даже если придется в разумных пределах потерять в простоте и эффективности. В то же время использование
структуры частной задачи почти всегда
позволяет найти лучшее решение, поэтому и специфические алгоритмы имеют право на существование;</p>

</body>
</html>